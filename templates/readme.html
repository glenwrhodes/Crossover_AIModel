<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>README</title>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
    <div class="container mt-4">
        <h1 id="ai-powered-recommendation-engine">AI-Powered Recommendation Engine</h1>
        <h2 id="overview">Overview</h2>
        <p>This project implements an AI-powered recommendation engine for an e-commerce platform using a hybrid recommendation system that combines collaborative filtering and content-based filtering. The engine is built using PyTorch for the model, Faiss for efficient similarity search, and Flask to create a web application for providing personalized product recommendations.</p>
        <h2 id="features">Features</h2>
        <ul>
        <li><strong>Data Preprocessing</strong>: Handles missing values and dataset cleaning.</li>
        <li><strong>Hybrid Recommendation System</strong>: Combines collaborative filtering and content-based filtering.</li>
        <li><strong>Caching</strong>: Uses Flask-Caching for low-latency responses.</li>
        <li><strong>Logging</strong>: Logs request handling and performance metrics.</li>
        <li><strong>Feedback Collection</strong>: Collects user feedback for continuous model evaluation and improvement.</li>
        </ul>
        <h2 id="setup">Setup</h2>
        <ol>
        <li><p><strong>Clone the Repository</strong>:</p>
        <pre><code class="lang-bash"> git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/glenwrhodes/Crossover_AIModel.git
         cd Crossover_AIModel
        </code></pre>
        </li>
        <li><p><strong>Install Dependencies</strong>:</p>
        <pre><code class="lang-bash"> pip <span class="hljs-keyword">install</span> -r requirements.txt
        </code></pre>
        </li>
        <li><p><strong>Train the Model</strong>:</p>
        <pre><code class="lang-bash"> <span class="hljs-keyword">python</span> model_train.<span class="hljs-keyword">py</span>
        </code></pre>
        </li>
        <li><p><strong>Run the Flask Application</strong>:</p>
        <pre><code class="lang-bash"> <span class="hljs-keyword">python</span> app.<span class="hljs-keyword">py</span>
        </code></pre>
        </li>
        </ol>
        <h2 id="usage">Usage</h2>
        <ul>
        <li>Access the application at <code>http://127.0.0.1:5000/</code>.</li>
        <li>Select a user to view personalized recommendations.</li>
        <li>Provide feedback on recommendations.</li>
        </ul>
        <h2 id="model-structure">Model Structure</h2>
        <h3 id="1-data-collection-and-preprocessing">1. Data Collection and Preprocessing</h3>
        <p><strong>Data Source</strong>:</p>
        <ul>
        <li>The dataset used is Amazon review data. The relevant columns include:<ul>
        <li><code>ProductId</code>: Identifies the product.</li>
        <li><code>UserId</code>: Identifies the user.</li>
        <li><code>Score</code>: The rating given by the user, which serves as the target variable.</li>
        <li><code>Summary</code> and <code>Text</code>: The review content utilized in content-based filtering.</li>
        </ul>
        </li>
        </ul>
        <p><strong>Data Integration</strong>:</p>
        <ul>
        <li>Primary dataset is read from a CSV file (<code>Reviews.csv</code>). If new reviews are available, they are integrated from <code>new_reviews.csv</code> to continuously update and improve the model.</li>
        </ul>
        <p><strong>Preprocessing Steps</strong>:</p>
        <ul>
        <li>Combine <code>Summary</code> and <code>Text</code> into a single <code>combined_text</code> column to use in the content-based filtering step.</li>
        </ul>
        <pre><code class="lang-python"># <span class="hljs-symbol">Example</span>: <span class="hljs-symbol">Combining</span> text columns
        df[<span class="hljs-string">'combined_text'</span>] = df[<span class="hljs-string">'Summary'</span>].fillna(<span class="hljs-string">''</span>) + <span class="hljs-string">' '</span> + df[<span class="hljs-string">'Text'</span>].fillna(<span class="hljs-string">''</span>)
        </code></pre>
        <h3 id="2-model-development">2. Model Development</h3>
        <p><strong>Collaborative Filtering</strong>:</p>
        <ul>
        <li>Utilizes a neural network model (CollaborativeFilteringModel) with embedding layers for users and items. This technique helps in capturing latent features from user-item interactions.</li>
        </ul>
        <pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollaborativeFilteringModel</span>(<span class="hljs-title">nn</span>.<span class="hljs-title">Module</span>):</span>
            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, num_users, num_items, embedding_dim, dropout_rate=<span class="hljs-number">0</span>.<span class="hljs-number">2</span>)</span></span>:
                <span class="hljs-keyword">super</span>(CollaborativeFilteringModel, <span class="hljs-keyword">self</span>).__init_<span class="hljs-number">_</span>()
                <span class="hljs-keyword">self</span>.user_embedding = nn.Embedding(num_users, embedding_dim)
                <span class="hljs-keyword">self</span>.item_embedding = nn.Embedding(num_items, embedding_dim)
                <span class="hljs-keyword">self</span>.user_bias = nn.Embedding(num_users, <span class="hljs-number">1</span>)
                <span class="hljs-keyword">self</span>.item_bias = nn.Embedding(num_items, <span class="hljs-number">1</span>)
                <span class="hljs-keyword">self</span>.global_bias = nn.Parameter(torch.zeros(<span class="hljs-number">1</span>))
                <span class="hljs-keyword">self</span>.dropout = nn.Dropout(dropout_rate)
        
            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, user_id, item_id)</span></span>:
                user_emb = <span class="hljs-keyword">self</span>.user_embedding(user_id)
                item_emb = <span class="hljs-keyword">self</span>.item_embedding(item_id)
                user_bias = <span class="hljs-keyword">self</span>.user_bias(user_id).squeeze()
                item_bias = <span class="hljs-keyword">self</span>.item_bias(item_id).squeeze()
        
                <span class="hljs-comment"># Apply dropout to embeddings</span>
                user_emb = <span class="hljs-keyword">self</span>.dropout(user_emb)
                item_emb = <span class="hljs-keyword">self</span>.dropout(item_emb)
        
                dot_product = (user_emb * item_emb).sum(<span class="hljs-number">1</span>)
                <span class="hljs-keyword">return</span> dot_product + user_bias + item_bias + <span class="hljs-keyword">self</span>.global_bias
        </code></pre>
        <p><strong>Forward Method</strong>:</p>
        <ul>
        <li>Calculates the dot product between user and item embeddings, adds bias terms, and applies dropout.</li>
        </ul>
        <h3 id="3-data-loader">3. Data Loader</h3>
        <p><strong>Custom Dataset</strong>:</p>
        <ul>
        <li>The <code>AmazonReviewDataset</code> class maps user and item IDs to numerical indices. This mapping facilitates the embedding process and allows efficient data handling during training.</li>
        </ul>
        <p><strong>DataLoader</strong>:</p>
        <ul>
        <li>The <code>get_data_loader</code> function creates data loaders for the training and testing datasets, enabling batched processing to speed up training and evaluation.</li>
        </ul>
        <pre><code class="lang-python"><span class="hljs-comment"># Example: Creating DataLoader</span>
        train_loader, num_users, num_items, user_to_idx, idx_to_user, item_to_idx, <span class="hljs-attr">idx_to_item</span> = get_data_loader(train_df, batch_size)
        </code></pre>
        <h3 id="4-training-process">4. Training Process</h3>
        <p><strong>Hyperparameters</strong>:</p>
        <ul>
        <li><strong>Embedding Dimension</strong>: 32</li>
        <li><strong>Batch Size</strong>: 64</li>
        <li><strong>Learning Rate</strong>: 0.001</li>
        <li><strong>Weight Decay</strong>: 1e-5 (L2 regularization term)</li>
        <li><strong>Dropout Rate</strong>: 0.2</li>
        <li><strong>Number of Epochs</strong>: 20</li>
        </ul>
        <p><strong>Optimization</strong>:</p>
        <ul>
        <li><strong>Adam Optimizer</strong>: Used for optimization due to its efficiency and adaptive learning rate capabilities.</li>
        <li><strong>Learning Rate Scheduler (StepLR)</strong>: Reduces the learning rate by a factor (<code>gamma</code>, e.g., 0.1) every few epochs (<code>step_size</code>, e.g., 7), allowing the model to converge more gracefully.</li>
        </ul>
        <p><strong>Loss Function</strong>:</p>
        <ul>
        <li>The Mean Squared Error (MSE) Loss measures the average squared difference between the predicted and actual values. It is particularly suitable for regression tasks like rating prediction.</li>
        </ul>
        <pre><code class="lang-python"><span class="hljs-comment"># Example: Learning rate scheduler</span>
        <span class="hljs-attr">scheduler</span> = optim.lr_scheduler.StepLR(optimizer, <span class="hljs-attr">step_size=7,</span> <span class="hljs-attr">gamma=0.1)</span>
        </code></pre>
        <h3 id="5-evaluation-and-optimization">5. Evaluation and Optimization</h3>
        <p><strong>Metrics Tracked</strong>:</p>
        <ul>
        <li><strong>Training and Test Loss</strong></li>
        <li><strong>Accuracy</strong></li>
        <li><strong>Precision and Recall</strong></li>
        </ul>
        <p><strong>Model Saving</strong>:</p>
        <ul>
        <li>At the end of each epoch, the model&#39;s state, optimizer state, and metrics are saved to ensure that training can resume from the last checkpoint in case of interruptions.</li>
        </ul>
        <pre><code class="lang-python"># Example: Saving <span class="hljs-keyword">model</span> checkpoint
        torch.save({
            <span class="hljs-string">'epoch'</span>: epoch,
            <span class="hljs-string">'model_state_dict'</span>: <span class="hljs-keyword">model</span>.state_dict(),
            <span class="hljs-string">'optimizer_state_dict'</span>: optimizer.state_dict(),
            <span class="hljs-string">'loss'</span>: loss,
            <span class="hljs-string">'accuracy'</span>: accuracy
        }, path)
        </code></pre>
        <h3 id="6-recommendation-functions">6. Recommendation Functions</h3>
        <p><strong>Popular Items</strong>:</p>
        <ul>
        <li>Returns the most popular items based on average scores, serving as a fallback recommendation for new or inactive users.</li>
        </ul>
        <p><strong>Content-Based Recommendations</strong>:</p>
        <ul>
        <li>Uses TF-IDF (Term Frequency-Inverse Document Frequency) vectorization to convert text data into numerical form. Dimensionality reduction is then performed using Truncated SVD (Singular Value Decomposition). The Faiss library is used for efficient nearest-neighbor search, enabling quick retrieval of similar items.</li>
        </ul>
        <pre><code class="lang-python"><span class="hljs-comment"># Example: TF-IDF and Faiss for content-based filtering</span>
        <span class="hljs-attr">tfidf_matrix</span> = tfidf.fit_transform(df[<span class="hljs-string">'combined_text'</span>])
        </code></pre>
        <p><strong>Hybrid Recommendations</strong>:</p>
        <ul>
        <li>Combines collaborative filtering and content-based filtering. If the user is new or has minimal interaction data, popular items are recommended. Otherwise, it first generates collaborative recommendations and then enhances them with content-based suggestions.</li>
        </ul>
        <pre><code class="lang-python"><span class="hljs-comment"># Example: Hybrid recommendation function</span>
        def hybrid_recommendations(user_id, n=<span class="hljs-number">10</span>):
            <span class="hljs-keyword">if</span> user_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> user_to_idx:
                <span class="hljs-literal">return</span> get_popular_items(n)
            collaborative_recs = get_recommendations(user_id, n)
            hybrid_recs = []
            <span class="hljs-keyword">for</span> product_id <span class="hljs-keyword">in</span> collaborative_recs:
                content_recs = content_based_recommendations(product_id, <span class="hljs-comment">n//2)</span>
                hybrid_recs.extend(content_recs)
            hybrid_recs = list(<span class="hljs-built_in">set</span>(hybrid_recs))
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(hybrid_recs) &lt; n:
                hybrid_recs.extend(get_popular_items(n - <span class="hljs-built_in">len</span>(hybrid_recs)))
            <span class="hljs-literal">return</span> hybrid_recs[:n]
        </code></pre>
        <h3 id="8-integration-of-new-reviews">8. Integration of New Reviews</h3>
        <ul>
        <li>New reviews are seamlessly integrated whenever available. This approach enables the model to stay updated with the latest user feedback and preferences, thereby improving the recommendation quality.</li>
        </ul>
        <pre><code class="lang-python"><span class="hljs-meta"># Example: Integrating new reviews</span>
        <span class="hljs-keyword">if</span> os.path.exists(<span class="hljs-keyword">new</span><span class="hljs-type">_reviews_file</span>):<span class="hljs-type"></span>
            <span class="hljs-keyword">new</span><span class="hljs-type">_df</span> = pd.read_csv(<span class="hljs-keyword">new</span><span class="hljs-type">_reviews_file</span>)
            df = pd.concat([df, <span class="hljs-keyword">new</span><span class="hljs-type">_df</span>], ignore_index=True)
        </code></pre>
        <h2 id="continuous-evaluation">Continuous Evaluation</h2>
        <ul>
        <li><strong>Logging</strong>: Logs are stored in <code>app.log</code>.</li>
        <li><strong>Feedback</strong>: User feedback is stored in <code>new_reviews.csv</code>.</li>
        </ul>
        <h2 id="scalability-and-performance">Scalability and Performance</h2>
        <ul>
        <li><strong>Caching</strong>: Uses Flask-Caching for low-latency responses.</li>
        </ul>
        <h2 id="evaluation-and-optimization">Evaluation and Optimization</h2>
        <ul>
        <li><strong>Metrics</strong>: Tracked and visualized over epochs for training/testing loss, accuracy, precision, and recall.</li>
        </ul>
        <h2 id="conclusion">Conclusion</h2>
        <p>This recommendation engine leverages collaborative filtering, content-based filtering, and a hybrid approach to provide personalized product recommendations. The training process is robust, incorporating techniques to prevent overfitting and ensuring scalability and performance. The model continuously evaluates and optimizes itself, making it a comprehensive solution for an e-commerce platform.</p>
        
    </div>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js"></script>
</body>
</html>